分布式锁知识点

## 为什么需要分布式锁
如果是单机情况下（单JVM），线程之间共享内存，只要使用线程锁就可以解决并发问题。如果是分布式情况下（多JVM），线程A和线程B很可能不是在同一JVM中，这样线程锁就无法起到作用了，这时候就要用到分布式锁来解决。

共享资源共同编辑场景：  
效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。

共享资源单一编辑场景：  
正确性:加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。

更好的例子看这个（超卖）：[分布式锁的使用场景与方式](https://segmentfault.com/a/1190000022935064)  
购物平台，因为量上去了，必须多个Application服务器集群分担用户流量，还需要预先将商品库存保存在redis保证并发性能。假设一个事务是：  
1）用户下订单  
2）检查redis库存，比如1个  
3）更新数据库库存，比如降为0  
4）更新redis库存，更新为和数据库一样为0  
5）执行其他业务逻辑  
在单JVM的并发没有问题，只要锁定2，3，4就可以保证串行。但是集群下多个JVM是锁不住的，因为JVM1不会知道JVM2的状态，这个更新redis为0了，另外一个还在数据库那一步，仍然会导致超卖。    
因为2，3，4是一个需要全局的独占过程，所以可以用分布式锁来做，不过注意如果这个锁的事务很耗时的话，可能需要改设计，因为同一时间只有一个JVM能获得锁。

## 分布式锁的实现有哪些
1.Memcached分布式锁  
利用Memcached的add命令。此命令是原子性操作，只有在key不存在的情况下，才能add成功，也就意味着线程得到了锁。

2.Redis分布式锁  
和Memcached的方式类似，利用Redis的setnx命令。此命令同样是原子性操作，只有在key不存在的情况下，才能set成功。（setnx命令并不完善，后续会介绍替代方案）

3.Zookeeper分布式锁  
利用Zookeeper的顺序临时节点，来实现分布式锁和等待队列。Zookeeper设计的初衷，就是为了实现分布式锁服务的。

4.Chubby  
Google公司实现的粗粒度分布式锁服务，底层利用了Paxos一致性算法。  

在实现的时候要注意的几个关键点：  
1、锁信息必须是会过期超时的，不能让一个线程长期占有一个锁而导致死锁；  
2、同一时刻只能有一个线程获取到锁  

## Redis分布式锁的细节
简单来说就是设置一个key表示锁，移除这个key就是解锁了。

redis有3种部署方式：
1）单机模式  
2）master-slave + sentinel选举模式  
3）redis cluster模式  

使用redis做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要redis故障了。加锁就不行了。  
采用master-slave模式，加锁的时候只对一个节点加锁，即便通过sentinel做了高可用，但是如果master节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。  
为了避免这些问题，需要redis cluster。

1）加锁    
最简单就是使用setnx命令，
```
setnx(key, 1)
```
当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败。
2）解锁  
有加锁就得有解锁。当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式是执行del指令，伪代码如下：
```
del(key)
```
释放锁之后，其他线程就可以继续执行setnx命令来获得锁
3）锁超时  
锁超时是什么意思呢？如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住，别的线程再也别想进来。  
所以，setnx的key必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放。setnx不支持超时参数，所以需要额外的指令，伪代码如下：
```
expire(key，30)
```
合起来（伪代码）
```
if（setnx（key，1） == 1）{
  expire（key，30） 
  try { do something ...... } 
  finally { 
    del（key） 
  } 
}
```

问题：
1）问题是如果expire没执行就宕机了，锁就永生了。  
解决方法：使用Redis 2.6.12以上的的set命令取代setnx指令
```
set（key，1，30，NX）
```
2）del误删，当A锁时间太久超过了30秒，锁自动释放，B获得锁，然后A结束了删除了B的锁。  
解决方法：在del前作判断是不是自己加的锁  
```
//加锁
String threadId = Thread.currentThread().getId() set（key，threadId ，30，NX）
//解锁
if（threadId .equals(redisClient.get(key))）{ del(key) }
```
判断和释放锁是两个独立操作，不满足atomic，不是原子性操作。所以要还需要自己写事务包含加锁和解锁。
3）虽然解决误删，但是A,B同时运行，也不对  
解决方法：加上守护进程，给过期锁续航，如果过了29秒，线程A还没执行完，守护进行致性expire，给锁续上20秒。如果A执行完，就关闭守护进程。如果A宕机了，因为A和守护进程在同一个进程，所以守护进程也停止了，当该锁超时没人续，也就自动释放了。

整体实现非常的复杂。

## zookeeper分布式锁的细节
zookeeper通过文件来加锁

Zookeeper的文件系统包括：  
1.持久节点 （PERSISTENT）  
默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在 。
2.持久节点顺序节点（PERSISTENT_SEQUENTIAL）  
所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号  
3.临时节点（EPHEMERAL）  
和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除  
4.临时顺序节点（EPHEMERAL_SEQUENTIAL）  
顾名思义，临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。  

分布式锁就是通过zookeeper的临时顺序节点特性来实现的。步骤为：  
1）先创建持久节点ParentLock    
2）Client1想要获得锁，就在ParentLock下面创建临时顺序节点Lock1（就是个文件，或者说一个key）  
3）client1查找ParentLock下所有临时节点，如果Lock1是第一个就获得锁，否则继续等待  
4）此时如果client2来获取锁，在ParentLock下面创建了Lock2，因为Lock2不是第一个，所以需要等待    
5）此时client2向Lock1注册Watcher，监控Lock1，等待Lock1完成或者消失  
6）此时如果有client3同理，创建Lock3，注册Watcher等待Lock2   
7）锁的释放就是删除节点Lock1（或者client1客户端崩溃），这时client2就会收到通知，然后client2便利ParentLock下面的所有节点，判断是否是最小。如果是就获得了锁

## 分布式锁，Redis vs zookeeper
Zookeeper：  
容易用框架实现，有等待锁队列，提高了抢锁效率，即使在master宕机的情况下也能稳定运行。但是是树的结构，所以添加删除节点最少O(LogN)。

Redis:  
是key-value的结构，所以set和delete的性能高。不过实现复杂，要考虑超时原子性误删等情况。最重要的是没有等待锁，需要在客户端自旋来等锁，效率低。

简单来说，zookeeper可靠性比redis强太多，只是效率低了点，如果并发量不是特别大，追求可靠性，首选zookeeper。为了效率，则首选redis实现。

## 应用场景
真正的高并发，比如10万级别，用分布式锁并不是个好注意，因为全局同一时间只能处理一个锁定的事务，即使这个锁很快，依然是效率低下。通常还是需要分片sharding，比如10万分成10台机器，1台处理1万。nginx单机可以处理最多20万request/每秒单机。

## Reference
[分布式锁的作用及实现（Redis）](https://blog.csdn.net/L_BestCoder/article/details/79336986)  
[Zookeeper：分布式系统入门到实战](https://www.youtube.com/watch?v=BhosKsE8up8)  
[如何用Zookeeper实现分布式锁？](https://zhuanlan.zhihu.com/p/69638683)  
[程序员小灰-漫画：什么是分布式锁？](https://kknews.cc/code/xekly9g.html)